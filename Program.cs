using Vortice.SpirvCross;

public class Program
{
    public static void Main()
    {
        string type = "ps";

        ValveResourceFormat.CompiledShader.ShaderFile shader = new();
        shader.Read("shaders/csgo_customweapon_vulkan_50_" + type + ".vcs");
        
        for(var frame = 0; frame < shader.GetZFrameCount(); frame++) {
            ValveResourceFormat.CompiledShader.ZFrameFile zframe = shader.GetZFrameFileByIndex(frame);
            
            for(var source = 0; source < zframe.GpuSourceCount; source++) {
                string glsl = AttemptSpirvReflection((ValveResourceFormat.CompiledShader.VulkanSource)zframe.GpuSources[source], Backend.GLSL);

                using StreamWriter outputFile = new("glslshaders/" + type + "/" + frame + "-" + source + ".glsl", true);
                outputFile.WriteLine(glsl);
            }
        }
    }

    public static string AttemptSpirvReflection(ValveResourceFormat.CompiledShader.VulkanSource vulkanSource, Backend backend)
    {
        SpirvCrossApi.spvc_context_create(out var context).CheckResult();

        using var buffer = new StringWriter();

        try
        {
            SpirvCrossApi.spvc_context_parse_spirv(context, vulkanSource.Bytecode, out var parsedIr).CheckResult();
            SpirvCrossApi.spvc_context_create_compiler(context, backend, parsedIr, CaptureMode.TakeOwnership, out var compiler).CheckResult();

            SpirvCrossApi.spvc_compiler_create_compiler_options(compiler, out var options).CheckResult();

            if (backend == Backend.GLSL)
            {
                SpirvCrossApi.spvc_compiler_options_set_uint(options, CompilerOption.GLSLVersion, 460);
                SpirvCrossApi.spvc_compiler_options_set_bool(options, CompilerOption.GLSLES, SpirvCrossApi.SPVC_FALSE);
                SpirvCrossApi.spvc_compiler_options_set_bool(options, CompilerOption.GLSLVulkanSemantics, SpirvCrossApi.SPVC_TRUE);
                SpirvCrossApi.spvc_compiler_options_set_bool(options, CompilerOption.GLSLEmitUniformBufferAsPlainUniforms, SpirvCrossApi.SPVC_TRUE);
            }
            else if (backend == Backend.HLSL)
            {
                SpirvCrossApi.spvc_compiler_options_set_uint(options, CompilerOption.HLSLShaderModel, 61);
            }

            SpirvCrossApi.spvc_compiler_install_compiler_options(compiler, options);

            SpirvCrossApi.spvc_compiler_compile(compiler, out var code).CheckResult();

            buffer.WriteLine($"// SPIR-V source ({vulkanSource.MetaDataSize}), {backend} reflection with SPIRV-Cross by KhronosGroup");
            buffer.WriteLine($"// Generated by TwoNull use with Web Inspect");
            buffer.WriteLine();
            buffer.WriteLine(code.ReplaceLineEndings());
        }
        catch (Exception e)
        {
            buffer.WriteLine("/*");
            buffer.WriteLine($"SPIR-V reflection failed: {e.Message}");

            var lastError = SpirvCrossApi.spvc_context_get_last_error_string(context);

            if (!string.IsNullOrEmpty(lastError))
            {
                buffer.WriteLine();
                buffer.WriteLine(lastError);
            }

            buffer.WriteLine("*/");
        }
        finally
        {
            SpirvCrossApi.spvc_context_release_allocations(context);
            SpirvCrossApi.spvc_context_destroy(context);
        }

        return buffer.ToString();
    }
}